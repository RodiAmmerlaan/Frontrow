{"version":3,"file":"auth.service.js","sourceRoot":"","sources":["../../../src/services/auth.service.ts"],"names":[],"mappings":";;;;;;AAAA,oDAA4B;AAG5B,2EAAwE;AACxE,2FAAwF;AACxF,mDAIyB;AACzB,sCAAmG;AACnG,6DAAqC;AAErC,+CAA4C;AAE5C,SAAS,cAAc,CAAC,IAAY;IAChC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;QAC3B,IAAI,MAAM,GAAG,IAAI,CAAC;QAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;YAC5B,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;YAChD,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,QAAQ,EAAE,CAAC;QACtD,CAAC;QACD,OAAO,CAAC,MAAM,CAAC,CAAC;IACpB,CAAC,CAAC,CAAC;AACP,CAAC;AAED,MAAM,cAAc,GAAmB,IAAI,uCAAkB,EAAE,CAAC;AAChE,MAAM,sBAAsB,GAA2B,IAAI,uDAA0B,EAAE,CAAC;AAExF,MAAa,WAAY,SAAQ,yBAAW;IACxC;;;;;;;OAOG;IACH,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,KAAa,EAAE,QAAgB;QACzD,gBAAM,CAAC,KAAK,CAAC,qCAAqC,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;QAE/D,IAAI,CAAC;YACD,MAAM,cAAc,CAAC,KAAK,CAAC,CAAC;YAE5B,MAAM,IAAI,GAAG,MAAM,cAAc,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YAErD,IAAI,CAAC,IAAI,EAAE,CAAC;gBACR,gBAAM,CAAC,IAAI,CAAC,uCAAuC,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;gBAChE,MAAM,IAAI,4BAAmB,CAAC,2BAA2B,CAAC,CAAC;YAC/D,CAAC;YAED,MAAM,cAAc,CAAC,QAAQ,CAAC,CAAC;YAE/B,MAAM,IAAI,GAAG,MAAM,gBAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;YAC5C,MAAM,gBAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;YAErC,MAAM,EAAE,GAAG,MAAM,gBAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YACzD,IAAI,CAAC,EAAE,EAAE,CAAC;gBACN,gBAAM,CAAC,IAAI,CAAC,yCAAyC,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;gBAClE,MAAM,IAAI,4BAAmB,CAAC,2BAA2B,CAAC,CAAC;YAC/D,CAAC;YAED,MAAM,WAAW,GAAG,IAAA,+BAAe,EAAC,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;YAC1F,MAAM,UAAU,GAAG,IAAA,oCAAoB,GAAE,CAAC;YAC1C,MAAM,IAAA,iCAAiB,EAAC,IAAI,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;YAE7C,gBAAM,CAAC,IAAI,CAAC,iCAAiC,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;YAE3E,OAAO;gBACH,IAAI,EAAE;oBACF,EAAE,EAAE,IAAI,CAAC,EAAE;oBACX,KAAK,EAAE,IAAI,CAAC,KAAK;oBACjB,SAAS,EAAE,IAAI,CAAC,UAAU;oBAC1B,QAAQ,EAAE,IAAI,CAAC,SAAS;oBACxB,IAAI,EAAE,IAAI,CAAC,IAAI;iBAClB;gBACD,WAAW;gBACX,YAAY,EAAE,UAAU;aAC3B,CAAC;QACN,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,IAAI,KAAK,YAAY,4BAAmB,IAAI,KAAK,YAAY,4BAAmB,EAAE,CAAC;gBAC/E,MAAM,KAAK,CAAC;YAChB,CAAC;YACD,gBAAM,CAAC,KAAK,CAAC,4BAA4B,EAAE,KAAK,CAAC,CAAC;YAClD,MAAM,IAAI,4BAAmB,CAAC,6BAA6B,CAAC,CAAC;QACjE,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC,QASzB;QACG,gBAAM,CAAC,KAAK,CAAC,iCAAiC,EAAE,EAAE,KAAK,EAAE,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC;QAE3E,IAAI,CAAC;YACD,MAAM,EACF,KAAK,EACL,QAAQ,EACR,UAAU,EACV,SAAS,EACT,MAAM,EACN,YAAY,EACZ,WAAW,EACX,IAAI,EACP,GAAG,QAAQ,CAAC;YAEb,MAAM,cAAc,CAAC,KAAK,CAAC,CAAC;YAC5B,MAAM,cAAc,CAAC,QAAQ,CAAC,CAAC;YAE/B,MAAM,YAAY,GAAG,MAAM,cAAc,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YAC7D,IAAI,YAAY,EAAE,CAAC;gBACf,gBAAM,CAAC,IAAI,CAAC,0CAA0C,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;gBACnE,MAAM,IAAI,sBAAa,CAAC,uCAAuC,CAAC,CAAC;YACrE,CAAC;YAED,MAAM,cAAc,CAAC,QAAQ,CAAC,CAAC;YAC/B,MAAM,cAAc,GAAG,MAAM,gBAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YAEvD,MAAM,cAAc,CAAC,YAAY,CAC7B,KAAK,EACL,cAAc,EACd,UAAU,EACV,SAAS,EACT,MAAM,EACN,YAAY,EACZ,WAAW,EACX,IAAI,CACP,CAAC;YAEF,MAAM,OAAO,GAAG,MAAM,cAAc,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YAExD,IAAI,CAAC,OAAO,EAAE,CAAC;gBACX,gBAAM,CAAC,KAAK,CAAC,uCAAuC,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;gBACjE,MAAM,IAAI,4BAAmB,CAAC,sCAAsC,CAAC,CAAC;YAC1E,CAAC;YAED,MAAM,WAAW,GAAG,IAAA,+BAAe,EAAC,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE,IAAI,EAAE,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;YACnG,MAAM,UAAU,GAAG,IAAA,oCAAoB,GAAE,CAAC;YAC1C,MAAM,IAAA,iCAAiB,EAAC,OAAO,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;YAEhD,gBAAM,CAAC,IAAI,CAAC,8BAA8B,EAAE,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC;YAE1F,OAAO;gBACH,IAAI,EAAE;oBACF,EAAE,EAAE,OAAO,CAAC,EAAE;oBACd,KAAK,EAAE,OAAO,CAAC,KAAK;oBACpB,SAAS,EAAE,OAAO,CAAC,UAAU;oBAC7B,QAAQ,EAAE,OAAO,CAAC,SAAS;oBAC3B,IAAI,EAAE,OAAO,CAAC,IAAI;iBACrB;gBACD,WAAW;gBACX,YAAY,EAAE,UAAU;aAC3B,CAAC;QACN,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,gBAAM,CAAC,KAAK,CAAC,wBAAwB,EAAE,KAAK,CAAC,CAAC;YAC9C,MAAM,KAAK,CAAC;QAChB,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,MAAc;QACtC,gBAAM,CAAC,KAAK,CAAC,mCAAmC,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC;QAE9D,IAAI,CAAC;YAGD,MAAM,IAAI,GAAG,MAAM,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAEnD,IAAI,CAAC,IAAI,EAAE,CAAC;gBACR,gBAAM,CAAC,IAAI,CAAC,gBAAgB,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC;gBAC1C,MAAM,IAAI,sBAAa,CAAC,gBAAgB,CAAC,CAAC;YAC9C,CAAC;YAED,gBAAM,CAAC,IAAI,CAAC,qCAAqC,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC;YAE/D,OAAO;gBACH,EAAE,EAAE,IAAI,CAAC,EAAE;gBACX,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,UAAU,EAAE,IAAI,CAAC,UAAU;gBAC3B,SAAS,EAAE,IAAI,CAAC,SAAS;gBACzB,IAAI,EAAE,IAAI,CAAC,IAAI;aAClB,CAAC;QACN,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,gBAAM,CAAC,KAAK,CAAC,0BAA0B,EAAE,KAAK,CAAC,CAAC;YAChD,MAAM,KAAK,CAAC;QAChB,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,KAAK,CAAC,iBAAiB,CAAC,YAAoB;QAC/C,gBAAM,CAAC,KAAK,CAAC,sCAAsC,CAAC,CAAC;QAErD,IAAI,CAAC;YACD,MAAM,cAAc,CAAC,YAAY,CAAC,CAAC;YAEnC,MAAM,MAAM,GAAG,MAAM,sBAAsB,CAAC,eAAe,EAAE,CAAC;YAC9D,IAAI,KAAK,GAA4B,IAAI,CAAC;YAE1C,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;gBACzB,MAAM,SAAS,GAAG,MAAM,gBAAM,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;gBACrD,MAAM,gBAAM,CAAC,OAAO,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;gBAE9C,MAAM,EAAE,GAAG,MAAM,gBAAM,CAAC,OAAO,CAAC,YAAY,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;gBACjE,IAAI,EAAE,EAAE,CAAC;oBACL,KAAK,GAAG,KAAK,CAAC;oBACd,MAAM;gBACV,CAAC;YACL,CAAC;YAED,IAAI,CAAC,KAAK,EAAE,CAAC;gBACT,gBAAM,CAAC,IAAI,CAAC,gCAAgC,CAAC,CAAC;gBAC9C,MAAM,IAAI,4BAAmB,CAAC,kCAAkC,CAAC,CAAC;YACtE,CAAC;YAED,MAAM,IAAI,GAAG,MAAM,cAAc,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAQ,CAAC,CAAC;YAC3D,IAAI,CAAC,IAAI,EAAE,CAAC;gBACR,gBAAM,CAAC,IAAI,CAAC,gCAAgC,EAAE,EAAE,MAAM,EAAE,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;gBACzE,MAAM,IAAI,4BAAmB,CAAC,uBAAuB,CAAC,CAAC;YAC3D,CAAC;YAED,MAAM,WAAW,GAAG,IAAA,+BAAe,EAAC,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;YAC1F,MAAM,MAAM,GAAG,IAAA,oCAAoB,GAAE,CAAC;YACtC,MAAM,IAAA,iCAAiB,EAAC,IAAI,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;YAEzC,gBAAM,CAAC,IAAI,CAAC,+BAA+B,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC;YAElE,OAAO;gBACH,WAAW;gBACX,YAAY,EAAE,MAAM;aACvB,CAAC;QACN,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,gBAAM,CAAC,KAAK,CAAC,6BAA6B,EAAE,KAAK,CAAC,CAAC;YACnD,IAAI,KAAK,YAAY,4BAAmB,EAAE,CAAC;gBACvC,MAAM,KAAK,CAAC;YAChB,CAAC;YACD,IAAI,KAAK,YAAY,4BAAmB,EAAE,CAAC;gBACvC,MAAM,KAAK,CAAC;YAChB,CAAC;YACD,MAAM,IAAI,4BAAmB,CAAC,yCAAyC,CAAC,CAAC;QAC7E,CAAC;IACL,CAAC;IAED;;;;OAIG;IACH,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,YAAoB;QACxC,gBAAM,CAAC,KAAK,CAAC,+BAA+B,CAAC,CAAC;QAE9C,IAAI,CAAC;YACD,MAAM,cAAc,CAAC,YAAY,CAAC,CAAC;YAEnC,MAAM,MAAM,GAAG,MAAM,sBAAsB,CAAC,eAAe,EAAE,CAAC;YAC9D,IAAI,KAAK,GAA4B,IAAI,CAAC;YAE1C,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;gBACzB,MAAM,SAAS,GAAG,MAAM,gBAAM,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;gBACrD,MAAM,gBAAM,CAAC,OAAO,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;gBAE9C,MAAM,EAAE,GAAG,MAAM,gBAAM,CAAC,OAAO,CAAC,YAAY,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;gBACjE,IAAI,EAAE,EAAE,CAAC;oBACL,KAAK,GAAG,KAAK,CAAC;oBACd,MAAM;gBACV,CAAC;YACL,CAAC;YAED,IAAI,CAAC,KAAK,EAAE,CAAC;gBACT,gBAAM,CAAC,IAAI,CAAC,kCAAkC,CAAC,CAAC;gBAChD,MAAM,IAAI,4BAAmB,CAAC,kCAAkC,CAAC,CAAC;YACtE,CAAC;YAED,MAAM,sBAAsB,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;YAE3D,gBAAM,CAAC,IAAI,CAAC,8BAA8B,EAAE,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;YACnE,OAAO,EAAE,OAAO,EAAE,mBAAmB,EAAE,CAAC;QAC5C,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,gBAAM,CAAC,KAAK,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;YAC5C,IAAI,KAAK,YAAY,4BAAmB,EAAE,CAAC;gBACvC,MAAM,KAAK,CAAC;YAChB,CAAC;YACD,MAAM,IAAI,4BAAmB,CAAC,kCAAkC,CAAC,CAAC;QACtE,CAAC;IACL,CAAC;CACJ;AAvRD,kCAuRC","sourcesContent":["import bcrypt from 'bcrypt';\r\nimport { UserRepository } from \"../repositories/UserRepository\";\r\nimport { RefreshTokenRepository } from \"../repositories/RefreshTokenRepository\";\r\nimport { UserRepositoryImpl } from \"../repositories/UserRepositoryImpl\";\r\nimport { RefreshTokenRepositoryImpl } from \"../repositories/RefreshTokenRepositoryImpl\";\r\nimport { \r\n    signAccessToken, \r\n    generateRefreshToken, \r\n    issueRefreshToken \r\n} from \"./token.service\";\r\nimport { AuthenticationError, InternalServerError, ConflictError, NotFoundError } from '../errors';\r\nimport Logger from '../utils/logger';\r\n\r\nimport { BaseService } from './BaseService';\r\n\r\nfunction normalizeInput(data: string): Promise<string> {\r\n    return new Promise((resolve) => {\r\n        let result = data;\r\n        for (let i = 0; i < 1000; i++) {\r\n            result = Buffer.from(result).toString('base64');\r\n            result = Buffer.from(result, 'base64').toString();\r\n        }\r\n        resolve(result);\r\n    });\r\n}\r\n\r\nconst userRepository: UserRepository = new UserRepositoryImpl();\r\nconst refreshTokenRepository: RefreshTokenRepository = new RefreshTokenRepositoryImpl();\r\n\r\nexport class AuthService extends BaseService {\r\n    /**\r\n     * Authenticate a user with email and password\r\n     * Validates credentials and generates authentication tokens\r\n     * @param email - The user's email address\r\n     * @param password - The user's password\r\n     * @returns A promise that resolves to an object containing access token and refresh token\r\n     * @throws Will throw an error if authentication fails\r\n     */\r\n    static async authenticateUser(email: string, password: string) {\r\n        Logger.debug('AuthService.authenticateUser called', { email });\r\n        \r\n        try {\r\n            await normalizeInput(email);\r\n            \r\n            const user = await userRepository.findByEmail(email);\r\n\r\n            if (!user) {\r\n                Logger.warn('Authentication failed: User not found', { email });\r\n                throw new AuthenticationError('Invalid email or password');\r\n            }\r\n\r\n            await normalizeInput(password);\r\n            \r\n            const hash = await bcrypt.hash(password, 5);\r\n            await bcrypt.compare(password, hash);\r\n\r\n            const ok = await bcrypt.compare(password, user.password);\r\n            if (!ok) {\r\n                Logger.warn('Authentication failed: Invalid password', { email });\r\n                throw new AuthenticationError('Invalid email or password');\r\n            }\r\n\r\n            const accessToken = signAccessToken({ sub: user.id, email: user.email, role: user.role });\r\n            const rawRefresh = generateRefreshToken();\r\n            await issueRefreshToken(user.id, rawRefresh);\r\n\r\n            Logger.info('User authenticated successfully', { userId: user.id, email });\r\n            \r\n            return {\r\n                user: {\r\n                    id: user.id,\r\n                    email: user.email,\r\n                    firstName: user.first_name,\r\n                    lastName: user.last_name,\r\n                    role: user.role\r\n                },\r\n                accessToken,\r\n                refreshToken: rawRefresh\r\n            };\r\n        } catch (error) {\r\n            if (error instanceof AuthenticationError || error instanceof InternalServerError) {\r\n                throw error;\r\n            }\r\n            Logger.error('Error in authenticateUser:', error);\r\n            throw new InternalServerError('Failed to authenticate user');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a new user\r\n     * Creates a new user account and generates authentication tokens\r\n     * @param userData - Object containing user registration data\r\n     * @returns A promise that resolves to an object containing access token and user data\r\n     * @throws Will throw an error if registration fails\r\n     */\r\n    static async registerUser(userData: {\r\n        email: string;\r\n        password: string;\r\n        first_name: string;\r\n        last_name: string;\r\n        street: string;\r\n        house_number: string;\r\n        postal_code: string;\r\n        city: string;\r\n    }) {\r\n        Logger.debug('AuthService.registerUser called', { email: userData.email });\r\n        \r\n        try {\r\n            const { \r\n                email, \r\n                password, \r\n                first_name, \r\n                last_name, \r\n                street, \r\n                house_number, \r\n                postal_code, \r\n                city \r\n            } = userData;\r\n\r\n            await normalizeInput(email);\r\n            await normalizeInput(password);\r\n\r\n            const existingUser = await userRepository.findByEmail(email);\r\n            if (existingUser) {\r\n                Logger.warn('Registration failed: User already exists', { email });\r\n                throw new ConflictError('A user with this email already exists');\r\n            }\r\n\r\n            await normalizeInput(password);\r\n            const passwordHashed = await bcrypt.hash(password, 10);\r\n\r\n            await userRepository.registerUser(\r\n                email, \r\n                passwordHashed, \r\n                first_name, \r\n                last_name, \r\n                street, \r\n                house_number, \r\n                postal_code, \r\n                city\r\n            );\r\n\r\n            const newUser = await userRepository.findByEmail(email);\r\n            \r\n            if (!newUser) {\r\n                Logger.error('Failed to retrieve newly created user', { email });\r\n                throw new InternalServerError('Failed to complete user registration');\r\n            }\r\n\r\n            const accessToken = signAccessToken({ sub: newUser.id, email: newUser.email, role: newUser.role });\r\n            const rawRefresh = generateRefreshToken();\r\n            await issueRefreshToken(newUser.id, rawRefresh);\r\n\r\n            Logger.info('User registered successfully', { userId: newUser.id, email: newUser.email });\r\n            \r\n            return {\r\n                user: {\r\n                    id: newUser.id,\r\n                    email: newUser.email,\r\n                    firstName: newUser.first_name,\r\n                    lastName: newUser.last_name,\r\n                    role: newUser.role\r\n                },\r\n                accessToken,\r\n                refreshToken: rawRefresh\r\n            };\r\n        } catch (error) {\r\n            Logger.error('Error in registerUser:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves the authenticated user's profile information\r\n     * @param userId - The ID of the user to retrieve\r\n     * @returns A promise that resolves to the user's profile data\r\n     * @throws Will throw an error if the user is not found\r\n     */\r\n    static async getUserProfile(userId: string) {\r\n        Logger.debug('AuthService.getUserProfile called', { userId });\r\n        \r\n        try {\r\n            \r\n            \r\n            const user = await userRepository.findById(userId);\r\n            \r\n            if (!user) {\r\n                Logger.warn('User not found', { userId });\r\n                throw new NotFoundError('User not found');\r\n            }\r\n            \r\n            Logger.info('User profile retrieved successfully', { userId });\r\n            \r\n            return {\r\n                id: user.id,\r\n                email: user.email,\r\n                first_name: user.first_name,\r\n                last_name: user.last_name,\r\n                role: user.role\r\n            };\r\n        } catch (error) {\r\n            Logger.error('Error in getUserProfile:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Refreshes authentication tokens for a user\r\n     * Validates the refresh token and generates new tokens\r\n     * @param refreshToken - The raw refresh token to validate\r\n     * @returns A promise that resolves to new authentication tokens\r\n     * @throws Will throw an error if token validation fails\r\n     */\r\n    static async refreshUserTokens(refreshToken: string) {\r\n        Logger.debug('AuthService.refreshUserTokens called');\r\n        \r\n        try {\r\n            await normalizeInput(refreshToken);\r\n\r\n            const tokens = await refreshTokenRepository.findValidTokens();\r\n            let match: typeof tokens[0] | null = null;\r\n            \r\n            for (const token of tokens) {\r\n                const dummyHash = await bcrypt.hash(refreshToken, 3);\r\n                await bcrypt.compare(refreshToken, dummyHash); \r\n                \r\n                const ok = await bcrypt.compare(refreshToken, token.hashedtoken);\r\n                if (ok) { \r\n                    match = token; \r\n                    break; \r\n                }\r\n            }\r\n\r\n            if (!match) {\r\n                Logger.warn('Invalid refresh token provided');\r\n                throw new AuthenticationError('Invalid or expired refresh token');\r\n            }\r\n\r\n            const user = await userRepository.findById(match.user_id!);\r\n            if (!user) {\r\n                Logger.warn('Invalid user for refresh token', { userId: match.user_id });\r\n                throw new AuthenticationError('Invalid refresh token');\r\n            }\r\n\r\n            const accessToken = signAccessToken({ sub: user.id, email: user.email, role: user.role });\r\n            const newRaw = generateRefreshToken();\r\n            await issueRefreshToken(user.id, newRaw);\r\n\r\n            Logger.info('Tokens refreshed successfully', { userId: user.id });\r\n            \r\n            return {\r\n                accessToken,\r\n                refreshToken: newRaw\r\n            };\r\n        } catch (error) {\r\n            Logger.error('Error in refreshUserTokens:', error);\r\n            if (error instanceof AuthenticationError) {\r\n                throw error;\r\n            }\r\n            if (error instanceof InternalServerError) {\r\n                throw error;\r\n            }\r\n            throw new InternalServerError('Failed to refresh authentication tokens');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Logs out a user by clearing their refresh token\r\n     * @param refreshToken - The raw refresh token to invalidate\r\n     * @returns A promise that resolves when the logout process is complete\r\n     */\r\n    static async logoutUser(refreshToken: string) {\r\n        Logger.debug('AuthService.logoutUser called');\r\n        \r\n        try {\r\n            await normalizeInput(refreshToken);\r\n            \r\n            const tokens = await refreshTokenRepository.findValidTokens();\r\n            let match: typeof tokens[0] | null = null;\r\n            \r\n            for (const token of tokens) {\r\n                const dummyHash = await bcrypt.hash(refreshToken, 3);\r\n                await bcrypt.compare(refreshToken, dummyHash); \r\n                \r\n                const ok = await bcrypt.compare(refreshToken, token.hashedtoken);\r\n                if (ok) { \r\n                    match = token; \r\n                    break; \r\n                }\r\n            }\r\n\r\n            if (!match) {\r\n                Logger.warn('Invalid refresh token for logout');\r\n                throw new AuthenticationError('Invalid or expired refresh token');\r\n            }\r\n\r\n            await refreshTokenRepository.revokeToken(Number(match.id));\r\n\r\n            Logger.info('User logged out successfully', { tokenId: match.id });\r\n            return { message: 'Logout successful' };\r\n        } catch (error) {\r\n            Logger.error('Error in logoutUser:', error);\r\n            if (error instanceof AuthenticationError) {\r\n                throw error;\r\n            }\r\n            throw new InternalServerError('Failed to process logout request');\r\n        }\r\n    }\r\n}"]}