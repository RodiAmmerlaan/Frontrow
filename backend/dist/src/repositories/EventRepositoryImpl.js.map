{"version":3,"file":"EventRepositoryImpl.js","sourceRoot":"","sources":["../../../src/repositories/EventRepositoryImpl.ts"],"names":[],"mappings":";;;AACA,6DAA0D;AAE1D,+DAAiF;AAEjF,MAAa,mBAAoB,SAAQ,uCAAkC;IACzE;;;;OAIG;IACH,KAAK,CAAC,QAAQ,CAAC,EAAU;QACvB,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IAChE,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,OAAO;QACX,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;IAC7C,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,MAAM,CAAC,SAA4C;QACvD,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC;IAC9D,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,MAAM,CAAC,EAAU,EAAE,SAA0B;QACjD,IAAI,CAAC;YACH,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC;gBACrC,KAAK,EAAE,EAAE,EAAE,EAAE;gBACb,IAAI,EAAE,SAAS;aAChB,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,KAAU,EAAE,CAAC;YACpB,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;gBAC3B,MAAM,IAAI,qCAAmB,CAAC,iBAAiB,EAAE,YAAY,CAAC,CAAC;YACjE,CAAC;YACD,MAAM,IAAI,iCAAe,CAAC,kCAAkC,EAAE,KAAK,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;QACtF,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,MAAM,CAAC,EAAU;QACrB,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;YACnD,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,OAAO,KAAU,EAAE,CAAC;YACpB,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;gBAC3B,MAAM,IAAI,qCAAmB,CAAC,iBAAiB,EAAE,YAAY,CAAC,CAAC;YACjE,CAAC;YACD,MAAM,IAAI,iCAAe,CAAC,kCAAkC,EAAE,KAAK,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;QACtF,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,MAAM,CAAC,EAAU;QACrB,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;QACrE,OAAO,CAAC,CAAC,KAAK,CAAC;IACjB,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,WAAW,CAAC,KAAa;QAC7B,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;IAClE,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,YAAY,CAAC,UAAkB;QACnC,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC;YACvC,KAAK,EAAE;gBACL,KAAK,EAAE;oBACL,QAAQ,EAAE,UAAU,CAAC,WAAW,EAAE;oBAClC,IAAI,EAAE,aAAa;iBACpB;aACF;YACD,OAAO,EAAE;gBACP,UAAU,EAAE,KAAK;aAClB;SACF,CAAC,CAAC;IACL,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,aAAa;QACjB,MAAM,GAAG,GAAG,IAAI,IAAI,EAAE,CAAC;QACvB,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC;YACvC,KAAK,EAAE;gBACL,UAAU,EAAE;oBACV,GAAG,EAAE,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;iBACvD;aACF;YACD,OAAO,EAAE;gBACP,UAAU,EAAE,KAAK;aAClB;SACF,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,eAAe,CAAC,SAAe,EAAE,OAAa;QAClD,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC;YACvC,KAAK,EAAE;gBACL,UAAU,EAAE;oBACV,GAAG,EAAE,SAAS;oBACd,GAAG,EAAE,OAAO;iBACb;aACF;YACD,OAAO,EAAE;gBACP,UAAU,EAAE,KAAK;aAClB;SACF,CAAC,CAAC;IACL,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,aAAa,CAAC,OAAe;QACjC,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC;QAE7E,IAAI,KAAK,EAAE,CAAC;YACR,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC;gBAC3D,KAAK,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE;gBAC5B,MAAM,EAAE;oBACJ,aAAa,EAAE,IAAI;oBACnB,KAAK,EAAE,IAAI;iBACd;aACJ,CAAC,CAAC;YAEH,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC;YAEpF,OAAO;gBACH,GAAG,KAAK;gBACR,aAAa,EAAE,aAAa;gBAC5B,MAAM,EAAE;oBACJ,MAAM,EAAE,UAAU;iBACrB;aACJ,CAAC;QACN,CAAC;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;;;;;OAQG;IACH,KAAK,CAAC,sBAAsB,CAAC,KAAa,EAAE,WAAmB,EAAE,IAAY,EAAE,UAAgB,EAAE,QAAc;QAC7G,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC;YACnC,KAAK,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE;YACvB,MAAM,EAAE,EAAE;YACV,MAAM,EAAE;gBACJ,KAAK,EAAE,KAAK;gBACZ,WAAW,EAAE,WAAW;gBACxB,UAAU,EAAE,UAAU;gBACtB,QAAQ,EAAE,QAAQ;aACrB;SACJ,CAAC,CAAC;IACL,CAAC;CACF;AAhMD,kDAgMC","sourcesContent":["import { Events } from \"@prisma/client\";\r\nimport { BaseRepositoryImpl } from \"./BaseRepositoryImpl\";\r\nimport { EventRepository } from \"./EventRepository\";\r\nimport { RepositoryError, EntityNotFoundError } from '../errors/RepositoryError';\r\n\r\nexport class EventRepositoryImpl extends BaseRepositoryImpl<Events, string> implements EventRepository {\r\n  /**\r\n   * Find an event by its ID\r\n   * @param id - The unique identifier of the event\r\n   * @returns A promise that resolves to the event or null if not found\r\n   */\r\n  async findById(id: string): Promise<Events | null> {\r\n    return await this.prisma.events.findUnique({ where: { id } });\r\n  }\r\n\r\n  /**\r\n   * Find all events\r\n   * @returns A promise that resolves to an array of all events\r\n   */\r\n  async findAll(): Promise<Events[]> {\r\n    return await this.prisma.events.findMany();\r\n  }\r\n\r\n  /**\r\n   * Create a new event\r\n   * @param eventData - The event data to create\r\n   * @returns A promise that resolves to the created event\r\n   */\r\n  async create(eventData: Omit<Events, 'id' | 'created_at'>): Promise<Events> {\r\n    return await this.prisma.events.create({ data: eventData });\r\n  }\r\n\r\n  /**\r\n   * Update an existing event\r\n   * @param id - The unique identifier of the event to update\r\n   * @param eventData - The updated event data\r\n   * @returns A promise that resolves to the updated event or null if not found\r\n   */\r\n  async update(id: string, eventData: Partial<Events>): Promise<Events> {\r\n    try {\r\n      return await this.prisma.events.update({\r\n        where: { id },\r\n        data: eventData\r\n      });\r\n    } catch (error: any) {\r\n      if (error.code === 'P2025') { \r\n        throw new EntityNotFoundError(`Event with ID ${id} not found`);\r\n      }\r\n      throw new RepositoryError(`Failed to update event with ID ${id}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete an event by its ID\r\n   * @param id - The unique identifier of the event to delete\r\n   * @returns A promise that resolves to true if deletion was successful, false otherwise\r\n   */\r\n  async delete(id: string): Promise<boolean> {\r\n    try {\r\n      await this.prisma.events.delete({ where: { id } });\r\n      return true;\r\n    } catch (error: any) {\r\n      if (error.code === 'P2025') { \r\n        throw new EntityNotFoundError(`Event with ID ${id} not found`);\r\n      }\r\n      throw new RepositoryError(`Failed to delete event with ID ${id}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if an event exists by its ID\r\n   * @param id - The unique identifier to check\r\n   * @returns A promise that resolves to true if the event exists, false otherwise\r\n   */\r\n  async exists(id: string): Promise<boolean> {\r\n    const event = await this.prisma.events.findUnique({ where: { id } });\r\n    return !!event;\r\n  }\r\n\r\n  /**\r\n   * Find an event by its title\r\n   * @param title - The title of the event to find\r\n   * @returns A promise that resolves to the event or null if not found\r\n   */\r\n  async findByTitle(title: string): Promise<Events | null> {\r\n    return await this.prisma.events.findFirst({ where: { title } });\r\n  }\r\n\r\n  /**\r\n   * Search for events by name using a case-insensitive partial match\r\n   * @param searchTerm - The term to search for in event titles\r\n   * @returns A promise that resolves to an array of events matching the search term\r\n   */\r\n  async searchByName(searchTerm: string): Promise<Events[]> {\r\n    return await this.prisma.events.findMany({\r\n      where: {\r\n        title: {\r\n          contains: searchTerm.toUpperCase(),\r\n          mode: 'insensitive'\r\n        }\r\n      },\r\n      orderBy: {\r\n        start_time: 'asc'\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find all events ordered by date, filtering for future events\r\n   * @returns A promise that resolves to an array of events\r\n   */\r\n  async findAllByDate(): Promise<Events[]> {\r\n    const now = new Date();\r\n    return await this.prisma.events.findMany({\r\n      where: {\r\n        start_time: {\r\n          gte: new Date(now.getTime() - 1000 * 60 * 60 * 24 * 0) \r\n        }\r\n      },\r\n      orderBy: {\r\n        start_time: 'asc'\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find events within a date range\r\n   * @param startDate - The start date of the range\r\n   * @param endDate - The end date of the range\r\n   * @returns A promise that resolves to an array of events within the date range\r\n   */\r\n  async findByDateRange(startDate: Date, endDate: Date): Promise<Events[]> {\r\n    return await this.prisma.events.findMany({\r\n      where: {\r\n        start_time: {\r\n          gte: startDate,\r\n          lte: endDate\r\n        }\r\n      },\r\n      orderBy: {\r\n        start_time: 'asc'\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Finds an event by its ID with related ticket batches and order counts\r\n   * @param eventId - The unique identifier of the event\r\n   * @returns A promise that resolves to the event with related data, or null if not found\r\n   */\r\n  async findEventById(eventId: string) {\r\n    const event = await this.prisma.events.findFirst({ where: { id: eventId } });\r\n    \r\n    if (event) {\r\n        const ticketBatches = await this.prisma.ticketBatches.findMany({ \r\n            where: { event_id: eventId },\r\n            select: {\r\n                total_tickets: true,\r\n                price: true\r\n            }\r\n        });\r\n        \r\n        const orderCount = await this.prisma.orders.count({ where: { event_id: eventId } });\r\n        \r\n        return {\r\n            ...event,\r\n            TicketBatches: ticketBatches,\r\n            _count: {\r\n                Orders: orderCount\r\n            }\r\n        };\r\n    }\r\n    \r\n    return event;\r\n  }\r\n\r\n  /**\r\n   * Creates a new event or updates an existing one if the title already exists\r\n   * @param title - The title of the event\r\n   * @param description - The description of the event\r\n   * @param date - The date of the event in YYYY-MM-DD format\r\n   * @param start_time - The start time of the event in HH:MM format\r\n   * @param end_time - The end time of the event in HH:MM format\r\n   * @returns A promise that resolves to the created or updated event\r\n   */\r\n  async createEventWithDetails(title: string, description: string, date: string, start_time: Date, end_time: Date) {\r\n    return await this.prisma.events.upsert({\r\n        where: { title: title },\r\n        update: {},\r\n        create: {\r\n            title: title,\r\n            description: description,\r\n            start_time: start_time,\r\n            end_time: end_time\r\n        }\r\n    });\r\n  }\r\n}"]}