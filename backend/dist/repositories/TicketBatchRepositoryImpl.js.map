{"version":3,"file":"TicketBatchRepositoryImpl.js","sourceRoot":"","sources":["../../src/repositories/TicketBatchRepositoryImpl.ts"],"names":[],"mappings":";;;AACA,6DAA0D;AAG1D,MAAa,yBAA0B,SAAQ,uCAAyC;IACtF;;;;OAIG;IACH,KAAK,CAAC,QAAQ,CAAC,EAAU;QACvB,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IACvE,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,OAAO;QACX,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC;IACpD,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,MAAM,CAAC,eAAyD;QACpE,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,eAAe,EAAE,CAAC,CAAC;IAC3E,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,MAAM,CAAC,EAAU,EAAE,eAAuC;QAC9D,IAAI,CAAC;YACH,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;gBAC5C,KAAK,EAAE,EAAE,EAAE,EAAE;gBACb,IAAI,EAAE,eAAe;aACtB,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,MAAM,CAAC,EAAU;QACrB,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;YAC1D,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,MAAM,CAAC,EAAU;QACrB,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;QAClF,OAAO,CAAC,CAAC,WAAW,CAAC;IACvB,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,aAAa,CAAC,OAAe;QACjC,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE,KAAK,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC;IACpF,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,kBAAkB,CAAC,OAAe;QACtC,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,KAAK,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC;IACrF,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,iBAAiB,CAAC,QAAgB,EAAE,aAAqB,EAAE,KAAa;QAC5E,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC;YACrB,QAAQ,EAAE,QAAQ;YAClB,aAAa,EAAE,aAAa;YAC5B,KAAK,EAAE,KAAK;SACf,CAAC,CAAC;IACL,CAAC;CACF;AApGD,8DAoGC","sourcesContent":["import { TicketBatches } from \"@prisma/client\";\nimport { BaseRepositoryImpl } from \"./BaseRepositoryImpl\";\nimport { TicketBatchRepository } from \"./TicketBatchRepository\";\n\nexport class TicketBatchRepositoryImpl extends BaseRepositoryImpl<TicketBatches, string> implements TicketBatchRepository {\n  /**\n   * Find a ticket batch by its ID\n   * @param id - The unique identifier of the ticket batch\n   * @returns A promise that resolves to the ticket batch or null if not found\n   */\n  async findById(id: string): Promise<TicketBatches | null> {\n    return await this.prisma.ticketBatches.findUnique({ where: { id } });\n  }\n\n  /**\n   * Find all ticket batches\n   * @returns A promise that resolves to an array of all ticket batches\n   */\n  async findAll(): Promise<TicketBatches[]> {\n    return await this.prisma.ticketBatches.findMany();\n  }\n\n  /**\n   * Create a new ticket batch\n   * @param ticketBatchData - The ticket batch data to create\n   * @returns A promise that resolves to the created ticket batch\n   */\n  async create(ticketBatchData: Omit<TicketBatches, 'id' | 'created_at'>): Promise<TicketBatches> {\n    return await this.prisma.ticketBatches.create({ data: ticketBatchData });\n  }\n\n  /**\n   * Update an existing ticket batch\n   * @param id - The unique identifier of the ticket batch to update\n   * @param ticketBatchData - The updated ticket batch data\n   * @returns A promise that resolves to the updated ticket batch or null if not found\n   */\n  async update(id: string, ticketBatchData: Partial<TicketBatches>): Promise<TicketBatches | null> {\n    try {\n      return await this.prisma.ticketBatches.update({\n        where: { id },\n        data: ticketBatchData\n      });\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Delete a ticket batch by its ID\n   * @param id - The unique identifier of the ticket batch to delete\n   * @returns A promise that resolves to true if deletion was successful, false otherwise\n   */\n  async delete(id: string): Promise<boolean> {\n    try {\n      await this.prisma.ticketBatches.delete({ where: { id } });\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Check if a ticket batch exists by its ID\n   * @param id - The unique identifier to check\n   * @returns A promise that resolves to true if the ticket batch exists, false otherwise\n   */\n  async exists(id: string): Promise<boolean> {\n    const ticketBatch = await this.prisma.ticketBatches.findUnique({ where: { id } });\n    return !!ticketBatch;\n  }\n\n  /**\n   * Find ticket batches by event ID\n   * @param eventId - The ID of the event\n   * @returns A promise that resolves to an array of ticket batches for the event\n   */\n  async findByEventId(eventId: string): Promise<TicketBatches[]> {\n    return await this.prisma.ticketBatches.findMany({ where: { event_id: eventId } });\n  }\n\n  /**\n   * Find the first ticket batch for an event\n   * @param eventId - The ID of the event\n   * @returns A promise that resolves to the first ticket batch or null if not found\n   */\n  async findFirstByEventId(eventId: string): Promise<TicketBatches | null> {\n    return await this.prisma.ticketBatches.findFirst({ where: { event_id: eventId } });\n  }\n\n  /**\n   * Creates a new ticket batch for an event\n   * @param event_id - The ID of the event\n   * @param total_tickets - The total number of tickets in this batch\n   * @param price - The price per ticket\n   * @returns A promise that resolves to the created ticket batch\n   */\n  async createTicketBatch(event_id: string, total_tickets: number, price: number): Promise<TicketBatches> {\n    return await this.create({\n        event_id: event_id,\n        total_tickets: total_tickets,\n        price: price\n    });\n  }\n}"]}