{"version":3,"file":"token.service.js","sourceRoot":"","sources":["../../src/services/token.service.ts"],"names":[],"mappings":";;;;;AAsBA,0CAEC;AAOD,8CAEC;AAMD,oDAEC;AAQD,8CAWC;AAQD,oDAeC;AAnFD,gEAA+B;AAC/B,oDAA4B;AAC5B,oDAA4B;AAC5B,2CAA8C;AAC9C,sCAAuC;AAEvC,MAAM,MAAM,GAAG,IAAI,qBAAY,EAAE,CAAC;AAElC,MAAM,aAAa,GAAG,mBAAU,CAAC,aAAa,CAAC;AAC/C,MAAM,gBAAgB,GAAG,mBAAU,CAAC,gBAAgB,CAAC;AAQrD;;;;GAIG;AACH,SAAgB,eAAe,CAAC,OAAmB;IAC/C,OAAO,sBAAG,CAAC,IAAI,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;AAC5C,CAAC;AAAA,CAAC;AAEF;;;;GAIG;AACH,SAAgB,iBAAiB,CAAC,KAAa;IAC3C,OAAO,sBAAG,CAAC,MAAM,CAAC,KAAK,EAAE,aAAa,CAAgC,CAAC;AAC3E,CAAC;AAAA,CAAC;AAEF;;;GAGG;AACH,SAAgB,oBAAoB;IAChC,OAAO,gBAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AAClD,CAAC;AAAA,CAAC;AAEF;;;;;GAKG;AACI,KAAK,UAAU,iBAAiB,CAAC,MAAc,EAAE,QAAgB;IACpE,MAAM,MAAM,GAAG,MAAM,gBAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;IAC/C,MAAM,SAAS,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,gBAAgB,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;IAEhF,OAAO,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC;QAC9B,IAAI,EAAE;YACF,OAAO,EAAE,MAAM;YACf,WAAW,EAAE,MAAM;YACnB,SAAS,EAAE,SAAS;SACvB;KACJ,CAAC,CAAC;AACP,CAAC;AAAA,CAAC;AAEF;;;;;GAKG;AACI,KAAK,UAAU,oBAAoB,CAAC,MAAc,EAAE,QAAgB;IACvE,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC;QAC9C,KAAK,EAAE;YACH,OAAO,EAAE,MAAM;YACf,SAAS,EAAE,IAAI;YACf,SAAS,EAAE,EAAE,EAAE,EAAE,IAAI,IAAI,EAAE,EAAE;SAChC;KACJ,CAAC,CAAC;IAEH,KAAK,MAAM,CAAC,IAAI,MAAM,EAAE,CAAC;QACrB,MAAM,EAAE,GAAG,MAAM,gBAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC;QACzD,IAAI,EAAE;YAAE,OAAO,CAAC,CAAC;IACrB,CAAC;IAED,OAAO,IAAI,CAAC;AAChB,CAAC","sourcesContent":["import jwt from 'jsonwebtoken';\r\nimport crypto from 'crypto';\r\nimport bcrypt from 'bcrypt';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { JWT_CONFIG } from '../config';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nconst ACCESS_SECRET = JWT_CONFIG.ACCESS_SECRET;\r\nconst REFRESH_TTL_DAYS = JWT_CONFIG.REFRESH_TTL_DAYS;\r\n\r\nexport type JwtPayload = { \r\n    sub: string, \r\n    email: string,\r\n    role: string\r\n};\r\n\r\n/**\r\n * Signs a JWT access token with the provided payload\r\n * @param payload - The JWT payload containing user information\r\n * @returns The signed JWT access token\r\n */\r\nexport function signAccessToken(payload: JwtPayload) {\r\n    return jwt.sign(payload, ACCESS_SECRET);\r\n};\r\n\r\n/**\r\n * Verifies a JWT access token\r\n * @param token - The JWT token to verify\r\n * @returns The decoded JWT payload\r\n */\r\nexport function verifyAccessToken(token: string) {\r\n    return jwt.verify(token, ACCESS_SECRET) as JwtPayload & jwt.JwtPayload;\r\n};\r\n\r\n/**\r\n * Generates a cryptographically secure random refresh token\r\n * @returns A random hex string to be used as a refresh token\r\n */\r\nexport function generateRefreshToken() {\r\n    return crypto.randomBytes(48).toString('hex');\r\n};\r\n\r\n/**\r\n * Issues a new refresh token for a user and stores it in the database\r\n * @param userId - The ID of the user for whom to issue the token\r\n * @param rawToken - The raw refresh token to hash and store\r\n * @returns A promise that resolves to the created refresh token record\r\n */\r\nexport async function issueRefreshToken(userId: string, rawToken: string) {\r\n    const hashed = await bcrypt.hash(rawToken, 10);\r\n    const expiresAt = new Date(Date.now() + REFRESH_TTL_DAYS * 24 * 60 * 60 * 1000);\r\n\r\n    return prisma.refreshToken.create({\r\n        data: {\r\n            user_id: userId, \r\n            hashedtoken: hashed, \r\n            expiresat: expiresAt\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * Validates a refresh token for a user\r\n * @param userId - The ID of the user whose token to validate\r\n * @param rawToken - The raw refresh token to validate\r\n * @returns A promise that resolves to the valid refresh token record or null if invalid\r\n */\r\nexport async function validateRefreshtoken(userId: string, rawToken: string) {\r\n    const tokens = await prisma.refreshToken.findMany({\r\n        where: {\r\n            user_id: userId,\r\n            revokedat: null,\r\n            expiresat: { gt: new Date() }\r\n        }\r\n    });\r\n\r\n    for (const t of tokens) {\r\n        const ok = await bcrypt.compare(rawToken, t.hashedtoken);\r\n        if (ok) return t;\r\n    }\r\n\r\n    return null;\r\n}"]}